# 4. Indexer Guide

This guide provides comprehensive instructions for setting up and running the CrowdFUNding blockchain indexer, including its architecture and key components.

## Overview

The indexer is a **Ponder** application that listens to blockchain events in real-time and makes the data queryable via GraphQL and REST APIs. It serves as the bridge between on-chain data and the backend cache.

**Key Responsibilities:**
- Subscribe to blockchain events in real-time
- Index events into a queryable database
- Provide GraphQL and REST APIs for data access
- Keep backend cache synchronized with blockchain state

## Architecture

The indexer follows an event-driven architecture where blockchain events trigger handlers that update the local database.

```mermaid
flowchart TB
    subgraph Blockchain["Base Sepolia"]
        Campaign["Campaign.sol"]
        Badge["Badge.sol"]
    end

    subgraph EventHandlers["Event Handlers"]
        CampaignHandler["src/Campaign.ts"]
        BadgeHandler["src/Badge.ts"]
    end

    subgraph Database["Database"]
        Tables["Tables:\n- campaigns\n- donations\n- withdrawals\n- badges"]
    end

    subgraph APIs["API Layer"]
        GraphQL["GraphQL Endpoint\n:42069/graphql"]
        REST["REST Endpoints\n:42069/api/*"]
    end

    Campaign --> |"Events"| CampaignHandler
    Badge --> |"Events"| BadgeHandler
    CampaignHandler --> |"Insert/Update"| Tables
    BadgeHandler --> |"Insert/Update"| Tables
    Tables --> GraphQL
    Tables --> REST
```

### Key Architectural Decisions

The following table explains the major architectural choices:

| Decision | Implementation | Benefit |
|----------|---------------|---------|
| **Ponder Framework** | TypeScript-based indexer | Hot reload, type safety |
| **Event-Driven** | Handler per event type | Clear separation of concerns |
| **Dual API** | GraphQL + REST | Flexibility for consumers |
| **Portable DB** | SQLite (dev) / PostgreSQL (prod) | Easy development, scalable production |

## Prerequisites

Before setting up the indexer, ensure you have:

- **Node.js** v18.14 or higher
- **npm** or **pnpm**
- An RPC endpoint (Alchemy or public)

## Project Structure

The indexer has a simple, focused structure:

```
├── ponder.config.ts          # Ponder configuration
├── ponder.schema.ts          # Database schema definition
├── ponder-env.d.ts           # TypeScript declarations
├── abis/
│   ├── Campaign.json         # Campaign contract ABI
│   └── Badge.json            # Badge contract ABI
├── src/
│   ├── Campaign.ts           # Campaign event handlers
│   ├── Badge.ts              # Badge event handlers
│   └── api/
│       └── index.ts          # Custom REST endpoints
├── tsconfig.json             # TypeScript configuration
└── package.json              # Dependencies
```

## Database Schema

The indexer uses a schema defined in `ponder.schema.ts` that mirrors the on-chain data structure:

```mermaid
erDiagram
    CAMPAIGNS {
        integer id PK
        text name
        text creatorName
        hex owner
        bigint balance
        bigint targetAmount
        bigint creationTime
    }
    
    DONATIONS {
        text id PK "txHash-logIndex"
        integer campaignId FK
        hex donor
        bigint amount
        bigint blockNumber
        bigint timestamp
        hex transactionHash
    }
    
    WITHDRAWALS {
        text id PK
        integer campaignId FK
        hex owner
        bigint amount
        bigint timestamp
        hex transactionHash
    }
    
    BADGES {
        integer tokenId PK
        hex owner
        text name
        bigint timestamp
        hex transactionHash
    }

    CAMPAIGNS ||--o{ DONATIONS : "receives"
    CAMPAIGNS ||--o{ WITHDRAWALS : "has"
```

### Schema Definition

The following code shows how the schema is defined:

```typescript
// ponder.schema.ts
import { onchainTable, index, relations } from "ponder";

export const campaigns = onchainTable("campaigns", (t) => ({
  id: t.integer().primaryKey(),
  name: t.text().notNull(),
  creatorName: t.text().notNull(),
  owner: t.hex().notNull(),
  balance: t.bigint().notNull(),
  targetAmount: t.bigint().notNull(),
  creationTime: t.bigint().notNull(),
}), (table) => ({
  ownerIndex: index().on(table.owner),
}));

export const donations = onchainTable("donations", (t) => ({
  id: t.text().primaryKey(),        // txHash-logIndex
  campaignId: t.integer().notNull(),
  donor: t.hex().notNull(),
  amount: t.bigint().notNull(),
  blockNumber: t.bigint().notNull(),
  timestamp: t.bigint().notNull(),
  transactionHash: t.hex().notNull(),
}), (table) => ({
  campaignIdIndex: index().on(table.campaignId),
  donorIndex: index().on(table.donor),
}));
```

## Environment Setup

Create a `.env.local` file in the project root:

```env
# ============================
# Blockchain RPC
# ============================
PONDER_RPC_URL_1=https://sepolia.base.org

# For better performance, use Alchemy:
# PONDER_RPC_URL_1=https://base-sepolia.g.alchemy.com/v2/YOUR_API_KEY

# ============================
# Database (Optional for Production)
# ============================
# By default, Ponder uses SQLite for development
# For production, configure PostgreSQL:
# DATABASE_URL=postgresql://user:password@host:5432/ponder
```

### How to Get RPC URL

| Provider | How to Obtain |
|----------|---------------|
| **Alchemy** | [alchemy.com](https://alchemy.com) → Create App → Select Base Sepolia |
| **Infura** | [infura.io](https://infura.io) → Create Key → Enable Base |
| **Public** | `https://sepolia.base.org` (rate-limited, not recommended for production) |

## Installation

### Step 1: Install Dependencies

```bash
npm install
# or
pnpm install
```

### Step 2: Generate Types (Optional)

Generate TypeScript types from your schema:

```bash
npm run codegen
```

## Running the Indexer

### Development Mode

Start the indexer with hot-reload:

```bash
npm run dev
```

The indexer will:
1. Connect to Base Sepolia RPC
2. Start indexing from the configured start block
3. Listen for new events in real-time
4. Serve APIs at `http://localhost:42069`

### Production Mode

```bash
npm run start
```

## Event Handlers

Event handlers are the core of the indexer. Each handler processes a specific event type and updates the database accordingly.

### Campaign Events

The following handlers process Campaign contract events:

```typescript
// src/Campaign.ts
import { ponder } from "@/generated";

// Handle new campaign creation
ponder.on("Campaign:CampaignCreated", async ({ event, context }) => {
  const { db } = context;
  
  await db.campaigns.insert({
    id: Number(event.args.id),
    name: event.args.name,
    creatorName: event.args.creatorName,
    owner: event.args.owner,
    balance: BigInt(0),
    targetAmount: event.args.targetAmount,
    creationTime: event.args.creationTime,
  });
});

// Handle donations
ponder.on("Campaign:DonationReceived", async ({ event, context }) => {
  const { db } = context;
  
  // Create unique donation ID from transaction
  const donationId = `${event.transaction.hash}-${event.log.logIndex}`;
  
  // Insert donation record
  await db.donations.insert({
    id: donationId,
    campaignId: Number(event.args.id),
    donor: event.args.donor,
    amount: event.args.amount,
    blockNumber: event.block.number,
    timestamp: event.block.timestamp,
    transactionHash: event.transaction.hash,
  });
  
  // Update campaign balance
  await db.campaigns.update({
    id: Number(event.args.id),
    balance: (prev) => prev.balance + event.args.amount,
  });
});

// Handle withdrawals
ponder.on("Campaign:FundWithdrawn", async ({ event, context }) => {
  const { db } = context;
  
  await db.withdrawals.insert({
    id: `${event.transaction.hash}-${event.log.logIndex}`,
    campaignId: Number(event.args.id),
    owner: event.args.owner,
    amount: event.args.amount,
    timestamp: event.block.timestamp,
    transactionHash: event.transaction.hash,
  });
  
  // Update campaign balance
  await db.campaigns.update({
    id: Number(event.args.id),
    balance: (prev) => prev.balance - event.args.amount,
  });
});
```

### Badge Events

```typescript
// src/Badge.ts
import { ponder } from "@/generated";

ponder.on("Badge:BadgeMinted", async ({ event, context }) => {
  const { db } = context;
  
  await db.badges.insert({
    tokenId: Number(event.args.tokenId),
    owner: event.args.owner,
    name: event.args.name,
    timestamp: event.block.timestamp,
    transactionHash: event.transaction.hash,
  });
});
```

## API Endpoints

The indexer automatically provides both GraphQL and REST APIs based on your schema.

### GraphQL Playground

Access the GraphQL playground at `http://localhost:42069` to explore and test queries.

### REST Endpoints

The following REST endpoints are automatically generated:

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/health` | Health check |
| GET | `/api/campaigns` | List all campaigns |
| GET | `/api/campaigns/:id` | Get campaign by ID |
| GET | `/api/donations` | List all donations |
| GET | `/api/donations/user/:address` | User's donations |
| GET | `/api/badges` | List all badges |
| GET | `/api/badges/user/:address` | User's badges |

## GraphQL Examples

### Get All Campaigns

The following query retrieves the most recent campaigns with pagination:

```graphql
query GetCampaigns {
  campaigns(orderBy: "creationTime", orderDirection: "desc", first: 10) {
    items {
      id
      name
      creatorName
      owner
      balance
      targetAmount
      creationTime
    }
    pageInfo {
      hasNextPage
      endCursor
    }
  }
}
```

### Get Campaign with Donations

This query fetches a specific campaign along with its donation history:

```graphql
query GetCampaignDetails($id: Int!) {
  campaign(id: $id) {
    id
    name
    creatorName
    balance
    targetAmount
    donations(orderBy: "timestamp", orderDirection: "desc", first: 10) {
      items {
        id
        donor
        amount
        timestamp
        transactionHash
      }
    }
  }
}
```

### Get User's Donation History

This query retrieves all donations made by a specific user:

```graphql
query GetUserDonations($donor: String!) {
  donations(where: { donor: $donor }, orderBy: "timestamp", orderDirection: "desc") {
    items {
      id
      campaignId
      amount
      timestamp
      campaign {
        name
        creatorName
      }
    }
  }
}
```

### Get Platform Statistics

This query retrieves overall platform metrics:

```graphql
query GetStats {
  campaignCount: campaigns(first: 0) {
    totalCount
  }
  donationCount: donations(first: 0) {
    totalCount
  }
  badgeCount: badges(first: 0) {
    totalCount
  }
}
```

## Configuration

### ponder.config.ts

The configuration file defines which contracts to index and how:

```typescript
import { createConfig } from "ponder";
import { http } from "viem";

import { CampaignAbi } from "./abis/Campaign";
import { BadgeAbi } from "./abis/Badge";

export default createConfig({
  networks: {
    baseSepolia: {
      chainId: 84532,
      transport: http(process.env.PONDER_RPC_URL_1),
    },
  },
  contracts: {
    Campaign: {
      network: "baseSepolia",
      abi: CampaignAbi,
      address: "0x44e87aa98d721Dbcf368690bF5aAb1F3dD944dA9",
      startBlock: 12345678, // Deploy block
    },
    Badge: {
      network: "baseSepolia",
      abi: BadgeAbi,
      address: "0xaE32Df9Fb677aE68C5A1F956761a42e269Ebdc99",
      startBlock: 12345678,
    },
  },
});
```

## Deployment

### Railway

Railway provides easy deployment for Ponder:

1. Connect your GitHub repository
2. Set environment variables:
   - `PONDER_RPC_URL_1`
   - `DATABASE_URL` (if using PostgreSQL)
3. Configure:
   - Build: `npm install && npm run build`
   - Start: `npm run start`

### Docker

Create a Dockerfile for containerized deployment:

```dockerfile
FROM node:18-alpine

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .

EXPOSE 42069
CMD ["npm", "run", "start"]
```

## Integration with Backend

The backend polls the indexer to keep its cache synchronized. Configure the backend's `.env`:

```env
PONDER_URL=http://localhost:42069
# Or production URL:
# PONDER_URL=https://indexer.crowdfunding.example.com
```

The backend's auto-sync service polls the indexer every 30 seconds:

```mermaid
sequenceDiagram
    participant Backend
    participant Ponder as Ponder Indexer
    participant Cache as PostgreSQL

    loop Every 30 seconds
        Backend->>Ponder: GET /api/campaigns
        Ponder-->>Backend: Campaign data
        Backend->>Cache: Upsert campaigns
        
        Backend->>Ponder: GET /api/donations
        Ponder-->>Backend: Donation data
        Backend->>Cache: Upsert donations
    end
```

## Troubleshooting

### Indexer Not Starting

**Error:** `Failed to connect to RPC`

**Solution:** Verify `PONDER_RPC_URL_1` is valid and accessible.

### Missing Events

**Warning:** `Block not found`

**Solution:** Ensure `startBlock` in config matches the contract deployment block.

### Database Errors

**Error:** `SQLITE_CANTOPEN`

**Solution:** Ensure write permissions in the project directory.

### GraphQL Errors

**Error:** `Field not found`

**Solution:** Run `npm run codegen` to regenerate types after schema changes.

## Performance Tips

The following practices improve indexer performance:

| Tip | Explanation |
|-----|-------------|
| Use Alchemy/Infura | Public RPC is rate-limited |
| Set accurate startBlock | Skip unnecessary historical blocks |
| Use PostgreSQL in production | Better performance than SQLite |
| Add database indexes | Speed up frequent queries |
| Use pagination | Avoid loading large datasets |
